#!/bin/bash
#
# shk-linux-conf -- shk configuration files updater
# Copyright (C) 2012  Alan SCHNEIDER
#                     <shk.schneider[at]gmail.com>
#
# This program comes with ABSOLUTELY NO WARRANTY.
# This is free software, and you are welcome to redistribute it
# under certain conditions.
#

github_user="leonnib4"
github_repo="linux_conf"
repo_branch="master"
force="false"

function usage() {
    echo "Usage: shk-linux-conf [OPTIONS] <COMMAND>" >&2
    echo "       Options:" >&2
    echo "                --user=GITHUB_USER" >&2
    echo "                --repo=GITHUB_REPO" >&2
    echo "                --branch=REPO_BRANCH" >&2
    echo "                --force" >&2
    echo "       Commands:" >&2
    echo "                --list" >&2
    echo "                --check [GITHUB_FILE ...]" >&2
    echo "                --update [GITHUB_FILE ...]" >&2
    exit 1
}

[ $# -eq 0 ] && usage

for argv in $@ ; do
    var=$(echo $argv | cut -d'=' -f1)
    value=$(echo $argv | cut -d'=' -f2-)
    case $var in
	"--user") github_user="$value" && shift ;;
	"--repo") github_repo="$value" && shift ;;
	"--branch") repo_branch="$value" && shift ;;
	"--force") force="true" && shift ;;
	"--") shift && break ;;
    esac
done
echo "$github_user@github:$github_repo/$repo_branch"

[ -z "$github_user" ] || [ -z "$github_repo" ] || [ -z "$repo_branch" ] && usage

index=0
errors=0
downloads=0
local_files_array=()
local_tags_array=()
remote_files_array=()
remote_url_array=()
remote_paths_array=()
remote_tags_array=()

function get_file() {
    flag="$1"
    remote="$2"
    local="$3"
    dir=$(dirname "$local")
    tmp="/tmp/$(basename "$local")"
    [ ! -w "$dir" ] && printf "shk-linux-conf: $dir: permission denied" >&2 && errors=$(($errors + 1)) && return
    mkdir -p "$dir"
    if [ -n "$flag" ] ; then
	printf "  [$flag] '$remote' -> '$local'\n"
    else
	printf "  '$remote' -> '$local'\n"
    fi
    curl -s "$remote" > "$tmp"
    downloads=$(($download + 1))
    if [ $? -ne 0 ] || [ ! -f "$tmp" ] ; then
	size=0
    else
	size=$(stat -c %s "$tmp")
    fi
    if [ $size -ne 0 ] ; then
	mv "$tmp" "$local" >/dev/null
    else
	errors=$(($errors + 1))
	printf "  download failed\n" >&2
    fi
}

function get_local_infos() {
    path="$1"
    file=$(basename "$path")
    if [ ! -f "$path" ] ; then
	tag="0"
    else
        [ ! -r "$path" ] && printf "shk-linux-conf: $path: permission denied" >&2 && errors=$(($errors + 1)) && return 0
	tag=$(cat "$path" | egrep '^\S+ \S+ r[0-9]+$' | cut -d' ' -f3 | cut -c2-)
    fi
    if [ -n "$tag" ] ; then
	local_files_array[$index - 1]="$file"
	local_tags_array[$index - 1]="$tag"
	return 1
    fi
    local_files_array[$index - 1]="$file"
    local_tags_array[$index - 1]="0"
    return 0
}

function get_remote_infos() {
    url="https://raw.github.com/$github_user/$github_repo/$repo_branch/$file"
    tag=$(curl -s "$url" | egrep '^\S+ \S+ r[0-9]+$')
    path=$(echo "$tag" | cut -d' ' -f2 | sed -r "s#^~#$HOME#")
    tag=$(echo "$tag" | cut -d' ' -f3 | cut -c2-)
    if [ -n "$tag" ] ; then
	remote_files_array[$index]="$file"
	remote_url_array[$index]="$url"
	remote_paths_array[$index]="$path"
	remote_tags_array[$index]="$tag"
	index=$(($index + 1))
	return 1
    fi
    return 0
}

function list() {
    local uri="$1"
    [ -z "$uri" ] && return
    while read line ; do
        if [ -n "$(echo $line | egrep "/$github_user/$github_repo/blob/[0-9a-f]+/\S+")" ] ; then
	    file=$(echo "$line" | sed -r "s#^.+/$github_user/$github_repo/blob/[0-9a-f]+/(\S+)\".+\$#\1#")
	    printf "."
	    get_remote_infos "$file"
	    if [ $? -eq 1 ] ; then
	        get_local_infos "${remote_paths_array[$index - 1]}"
	    fi
        elif [ -n "$(echo $line | egrep "/$github_user/$github_repo/tree/[0-9a-f]+/\S+")" ] ; then
	    dir=$(echo "$line" | sed -r "s#^.+/$github_user/$github_repo/tree/[0-9a-f]+/(\S+)\".+\$#\1#")
            printf "."
            list "/tree/$repo_branch/$dir"
        fi
    done < <(curl -s "https://github.com/$github_user/$github_repo$uri" | grep "href=" | grep -v "rel='permalink'" | grep -v "Breadcrumb")
}

CMD="$1"
case $CMD in
    "--list")
	i=0
	list "/"
        printf "\n"
	while [ $i -lt $index ] ; do
	    echo "${remote_files_array[$i]} r${remote_tags_array[$i]} -- ${remote_paths_array[$i]}"
	    i=$(($i + 1))
	done
	;;
    "--check"|"--update")
	shift
	if [ $# -eq 0 ] ; then
	    list "/"
            printf "\n"
	else
	    for file in $@ ; do
		get_remote_infos "$file"
		if [ $? -eq 1 ] ; then
		    get_local_infos "${remote_paths_array[$index - 1]}"
		else
		    errors=$(($errors + 1))
		    echo "$file: no such remote file" >&2
		fi
	    done
	fi
	i=0
	while [ $i -lt $index ] ; do
	    echo -n "${remote_paths_array[$i]}: local(r${local_tags_array[$i]}) remote(r${remote_tags_array[$i]}) -- "
	    case $CMD in
		"--check")
		    if [ ${local_tags_array[$i]} -eq 0 ] ; then
			echo "file not found"
			[ $force = "true" ] && echo "  [force] will download"
		    elif [ ${local_tags_array[$i]} -eq ${remote_tags_array[$i]} ] ; then
			echo "up to date"
		    elif [ ${local_tags_array[$i]} -lt ${remote_tags_array[$i]} ] ; then
			echo "update available"
			echo "  will update"
		    else
			echo "something is wrong"
			[ $force = "true" ] && echo "  [force] will download"
		    fi
		    ;;
		"--update")
		    if [ ${local_tags_array[$i]} -eq 0 ] ; then
			echo "file not found"
			[ $force = "true" ] && get_file "force" "${remote_url_array[$i]}" "${remote_paths_array[$i]}"
		    elif [ ${local_tags_array[$i]} -eq ${remote_tags_array[$i]} ] ; then
			echo "up to date"
		    elif [ ${local_tags_array[$i]} -lt ${remote_tags_array[$i]} ] ; then
			echo "update available"
			get_file "" "${remote_url_array[$i]}" "${remote_paths_array[$i]}"
		    else
			echo "something is wrong"
			[ $force = "true" ] && get_file "force" "${remote_url_array[$i]}" "${remote_paths_array[$i]}"
		    fi
		    ;;
	    esac
	    i=$(($i + 1))
	done
	;;
    "--help")
	usage
	;;
    *)
	echo "$CMD: unknown command" >&2
	usage
	;;
esac

echo -n "$index remote files parsed, $downloads downloaded ($errors errors)"
[ $force = "true" ] && echo " [force]" || echo ""

# EOF
